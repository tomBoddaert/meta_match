var guideSections =[{"name":"","guides":[{"name":"../README.md","body":"# meta_match\n\n`meta_match` is a [zig](https://ziglang.org/) module that can match types for you!\nIt is designed to assist with meta-programming of things like interfaces.\n\n## Adding meta_match to your project\nIn `build.zig.zon`, put this in the `dependencies` field:\n```zig\n.meta_match = .{\n    .url = \"https://github.com/tomBoddaert/meta_match/archive/{commit}.tar.gz\",\n    .hash = \"{hash}\",\n}\n```\nWhere `{commit}` is replaced with the commit (e.g. `4129996211edd30b25c23454520fd78b2a70394b`)\nand hash with the result of `zig fetch https://github.com/tomBoddaert/meta_match/archive/{commit}.tar.gz`.\n\n## Example: go-like interfaces\nInterfaces in go are implemented implicitly, this means that any type that has the required\nfunctions and fields.\n\n```zig\n/// An interface for deinitialising.\n///\n/// If the type does not have a `deinit` function, the `deinit` function\n/// does nothing.\npub fn Deinit(comptime T: type) type {\n    return struct {\n        // This matches a compatable 'deinit' function\n        const DeinitMatch = TypeMatch{\n            .Fn = &FnMatch{\n                // Only accept zig and C functions\n                .calling_convention = .{ .options = &.{ .Unspecified, .C, .Inline } },\n                // Don't accept C variadic functions\n                .is_var_args = false,\n                // It must return void\n                .return_type = TypeMatch{ .Void = {} },\n                .params = &.{\n                    // It must have a single pointer parameter\n                    // Note that the 'constness' of this pointer is not specified,\n                    // so functions that take '*const T' will also be accepted.\n                    ParamMatch{\n                        .type = TypeMatch{\n                            .Pointer = &PointerMatch{\n                                // The pointer must point to one value\n                                .size = .{ .options = &.{Type.Pointer.Size.One} },\n                                // It must not be volatile\n                                .is_volatile = false,\n                                // It must be pointing to a 'T'\n                                .child = TypeMatch{ .by_type = T },\n                                // It must not have a sentinel\n                                // Note that if this was just 'null', meta_match would not\n                                // check it.\n                                .sentinel = @as(?*const anyopaque, null),\n                            },\n                        },\n                    },\n                },\n            },\n        };\n\n        /// The MetaMatch expression used to determine 'has_deinit'.\n        pub const MetaMatch = meta_match.TypeMatch{\n            .container = &.{\n                // It must be a container with a 'deinit' declaration matching 'DeinitMatch' above\n                .decls = &.{.{ .name = \"deinit\", .type = DeinitMatch }},\n            },\n        };\n\n        /// `true` if `T` has a `deinit` function.\n        pub const has_deinit: bool = MetaMatch.match(T);\n\n        /// Deinitialise a value.\n        pub inline fn deinit(value: *T) void {\n            if (has_deinit) {\n                T.deinit(value);\n            }\n        }\n    };\n}\n\ntest {\n    try testing.expect(!Deinit(u8).has_deinit);\n    var n: u8 = 5;\n    // This will do nothing\n    Deinit(u8).deinit(&n);\n\n    const S = struct {\n        pub fn deinit(_: *@This()) void {}\n    };\n    try testing.expect(Deinit(S).has_deinit);\n    var s = S{};\n    // This will run the deinit function\n    Deinit(S).deinit(&s);\n}\n```\n\nIn this example, if 'deinit' is called with a type that does not have a 'deinit' function, nothing happens but\nyou could add a compile error, or you could run a default function.\n"}]}];